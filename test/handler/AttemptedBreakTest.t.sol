//SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

import {Test} from "forge-std/Test.sol";
import {StdInvariant} from "forge-std/StdInvariant.sol";
import{HandlerStatefulFuzzCatches} from "../../src/invariant-break/HandlerStatefulFuzzCatches.sol";
import {MockUSDC} from "../mocks/MockUSDC.sol";
import {YeildERC20} from "../mocks/YeildERC20.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract AttemptedBreakTest is Test{
    HandlerStatefulFuzzCatches hsff_c;
    MockUSDC usdc;
    YeildERC20 yusdc;
    IERC20[] supportedTokens;
    uint256 startingAmount;

    address user=makeAddr("user");

    function setUp() public{
        vm.startPrank(user);
        yusdc= new YeildERC20();
        usdc= new MockUSDC();

        startingAmount= yusdc.INITIAL_SUPPLY();
        usdc.mint(user, startingAmount);
        vm.stopPrank(); 

        supportedTokens.push(usdc);
        supportedTokens.push(yusdc);
        hsff_c= new HandlerStatefulFuzzCatches(supportedTokens);
        
        targetContract(address(hsff_c)); 
    }

    function testStartingAmountTheSame()public{
        assert(startingAmount==yusdc.balanceOf(user));
        assert(startingAmount==usdc.balanceOf(user));
    }
    function statefulFuzz_testInvariantBreaks() public{
        vm.startPrank(user);
        hsff_c.withdrawToken(usdc);
        hsff_c.withdrawToken(yusdc);
        assert(usdc.balanceOf(address(hsff_c))==0);
        assert(yusdc.balanceOf(address(hsff_c))==0);

        assert(usdc.balanceOf(user)==startingAmount);
        assert(yusdc.balanceOf(user)==startingAmount);
    }
       
}
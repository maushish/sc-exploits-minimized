//SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

import {Test} from "forge-std/Test.sol";
import {StdInvariant} from "forge-std/StdInvariant.sol";
import{HandlerStatefulFuzzCatches} from "../../src/invariant-break/HandlerStatefulFuzzCatches.sol";
import {MockUSDC} from "../mocks/MockUSDC.sol";
import {YeildERC20} from "../mocks/YeildERC20.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {Handler} from "./handler.t.sol";
contract AttemptedBreakTest is Test{
    HandlerStatefulFuzzCatches hsff_c;
    MockUSDC usdc;
    YeildERC20 yusdc;
    IERC20[] supportedTokens;
    uint256 startingAmount;

    address user=makeAddr("user");


    function setUp() public{
        vm.startPrank(user);
        yusdc= new YeildERC20();
        usdc= new MockUSDC();

        startingAmount= yusdc.INITIAL_SUPPLY();
        usdc.mint(user, startingAmount);
        vm.stopPrank(); 

        supportedTokens.push(usdc);
        supportedTokens.push(yusdc);
        hsff_c= new HandlerStatefulFuzzCatches(supportedTokens);
        //using handler fuzzing 
        handler =new Handler(HandlerStatefulFuzzCatches, usdc, yusdc, user);
        
        bytes4[] memory selectors = new bytes4[](4);
        selectors[0]= handler.depositYeildERC20.selector;
        selectors[1]= handler.depositMockUSDC.selector;
        selectors[2]= handler.withdrawMockUSDC.selector;
        selectors[3]= handler.withdrawYeildERC20.selector;

        targetSelector(FuzzSelector(addr: address(handler), selectors: selectors));
        targetContract(address(handler));
    }
        function statefulFuzz_testInvariantBreaksHandler() public{
        vm.startPrank(user);
        hsff_c.withdrawToken(usdc);
        hsff_c.withdrawToken(yusdc);
        vm.stopPrank();

        assert(usdc.balanceOf(address(hsff_c))==0);
        assert(yusdc.balanceOf(address(hsff_c))==0);

        assert(usdc.balanceOf(user)==startingAmount);
        assert(yusdc.balanceOf(user)==startingAmount);
    }
}